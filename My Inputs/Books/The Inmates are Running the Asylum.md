---
created: 2023-12-30
status: 🔴
tags:
  - input
  - input/book
  - design
links: "[[My Inputs]]"
author: Alan Cooper
---
## Summary
### Context
- Written by interaction design consultant Alan Cooper, this still-relevant book from 2004 defends the importance of design in what was then the new world of consumer software production. It’s interesting to read about the product design industry in its infancy, and the inception of design techniques like personas and usability testing that we take for granted. Cooper’s pleas for better interaction design, and a design-led process are still aspirational today.
### Main Takeaways
- Making people feel stupid is terrible for business.
### Questions/Connections/Thoughts
- 
## Notes
In a discussion of the ways integrating computers into everyday objects leads to poor usability, Cooper predicts, ==“because it is far cheaper for manufacturers to use computers to control the internal functioning of devices than it is to use older, mechanical methods, it is economically inevitable that computers will insinuate themselves into every product and service in our lives.==” (p7).

Cooper explains that computer software is innately complex and confusing due to ==“cognitive friction. It is the resistance encountered by a human intellect when it engages with a complex system of rules that change as the problem changes. Software interaction is very high in cognitive friction. Interaction with physical devices, however complex, tends to be low in cognitive friction because mechanical devices tend to stay in a narrow range of states comparable to their inputs.==” (p19-20). Because computers are endless and everything they are incomprehensible. Cooper asserts that in response to cognitive friction, ==“each user learns the smallest set of features that he needs to get his work done, and he abandons the rest.==” (p33). 

Cooper defines interface design as ==“dress[ing] up existing behavior”, behavioural design as determining ==“how the software should act and communicate==” and conceptual design, as ==“consider[ing] what is valuable for the users in the first place.==” (p23). He suggests starting with conceptual design, then behavioural, then interface.

Cooper describes most software as a ==“dancing bear==” (p26), in that it does not do a task particularly well, but users remain impressed that it can do it at all. However, the landscape is changing and simply achieving the goal is no longer sufficient for software to be successful.

==“The use of a feature is inversely proportional to the amount of interaction needed to control it.==” (p33).


Cooper describes three types of user that are considered when making software: the ‘naive user’, ==“industry code for ‘stupid, incompetent user==” (p35), which Cooper explains are not actually stupid but subjected to poorly designed products, the ‘computer literate user’, who ==“has been hurt so many times that the scar tissue is thick enough that he no longer feels the pain==” (p35), meaning they do not really know how computers work but can troubleshoot along familiar paths to achieve most of their goals, and the ‘power user’, who ==“have sufficiently overcome their better instincts to be useful consumers of high-cognitive-friction products==” (p36), and enjoy the challenge of figuring out nonsensical software programs.

In a discussion of how ‘rude’ software is, Cooper explains that in human-systems, the big picture is visible and humans can adapt to the changing demands of the situation because they can see it. He gives the example of a paper in-box on someone’s desk being six inches or six feet deep, changing the actions of the person and their colleagues. If someone has a lull, they can help someone with a bigger stack, knowing they will do the same. When a system is computerized, only the precise task is translated and the human components are not, in this case, the computer acts the same regardless of the number of incoming items, so both the worker and their colleagues are disoriented from the amount of work. He explains, ==“this system flexibility is key to maintaining social order. In computerized systems, an inhuman rationality is imposed that wears away at the fabric of civilization.==” (p66).

Cooper explains how the poor design of an ATM, showing only the barest bones of information, one screen at a time, promotes errors and worse, makes users feel stupid and incompetent. He elaborates, ==“I’m sure some of the people who use the ATM are stupid and incompetent, but nobody– not even a stupid and incompetent person– likes to be treated as if he is stupid and incompetent. Besides, it never generates customer loyalty and good feelings to treat your clients that way.==” (p68). Making people feel stupid is the cardinal sin of design.

Cooper divides two kinds of people based on the ‘Jetaway Test’, in which when hypothetically boarding a plane, they either go left to the cockpit full of complexity or right to the cabin. Cooper elaborates, ==“those who turn left strongly desire to be in control and to understand how the technology works, and those who turn right strongly desire to simplify their thinking and to have confidence in the success of the flight. Programmers – Homo logicus – always want to turn left. Users – Homo sapiens – always want to turn right.==” (p94). 

==“The price of control is always more effort and increased complexity.==” (p96). 

Cooper explains that programmers generally want to look under the hood at how computer systems work, preferring an ‘implementation model’ where interactions mirror code. Users on the other hand, ==“are quite content to not know how something works, even though they use it and depend on it in their everyday lives. They see implementation-model interfaces as imposing an unnecessary burden of understanding on them.==” (p99). 

Cooper explains the ‘persona’, a detailed archetype designers use to keep the user in mind during interaction design development. ==“The broader a target you aim for, the more certainty you have of missing the bull’s-eye. If you want to achieve a product-satisfaction level of 50%, you cannot do it by making a large population 50% happy with your product. You can only accomplish it by singling out 50% of the people and striving to make them 100% happy. It goes further than that. You can create an even bigger success by targeting 10% of the market and working to make them 100% ecstatic. It might seem counterintuitive, but designing for a single user is the most effective way to satisfy a broad population.==” (p126). 


==“Whereas programming is defined by cases at the edge of the paradigm, design is defined at the center.==” (p130). Make a very detailed persona of a very stereotypical person.

Cooper explains how to increase discoverability by changing interface hierarchies with ‘monocline groupings’, ==“a single layer of information arranged into groups”, to reduce the depth of necessary interactions users need to take to reach their goals. (p145). 

Cooper advocates for his ‘Goal-Directed design’ methodology, in which goals and personas are the guiding light. He explains that goals are the reason people perform tasks, so focusing on these over tasks separates the design from the technology and ensures a human problem (as opposed to a technical one) is being solved. He notes that design used to be mainly concerned with aesthetics, hence subjective, whereas now the design of software can be systematically analyzed in terms of usability and user satisfaction.  (p149).

==“‘Good interaction design’ has meaning only in the context of a person actually using it for some purpose. You cannot have purposes without people. The two are inseparable. That is why the two key elements of our design process are goals and personas – purposes and people. What’s more, the most important goals are personal ones, held only by the individual. Some real person is interacting with your product, not some abstract corporation, so you must regard people’s personal goals as higher than the corporation’s.==” (p149). It’s interesting because corporations have the power in society, but within corporations, the whims of the people are in control. So somehow both are not in control?

Cooper explains the ‘Principle of Commensurate Effort’, where ==“people are willing to put effort into tasks because they feel that it is a fair exchange between equals. In other words, people are willing to invest extra effort because they know they will get extra rewards for it.==” (p155). In interaction design, this means making the product’s key features plug-and-play, and only requiring extra effort on users’ part after they have gotten a ‘reward’ from the product.

Cooper relays research from Stanford University professors Clifford Nass and Byron Reeves that observes how humans personify computers due to their interactive nature. He cites their points that, ==“‘people are not evolved to twentieth-century technology,’ and that ‘modern media not engaged old brains… Consequently, any medium that is close enough will get human treatment, even though people know it’s foolish and will likely deny it afterward.’ To our human minds, computers behave less like rocks and trees than they do like humans, so we unconsciously treat them like people, even when we ==“believe it is unreasonable to do so.==” (p159). 

Cooper explains the necessity of defining common terms for programmers and designer to use when working on a product, to ensure joint understanding of the project goals and requirements. He continues, ==“the terms we select are not those that will be plastered on the outside of the box. We use our vocabulary internally, so we don’t care about the marketing palatability of the words. They need only be precise.==” (p186). Considering the audience when communicating, not everything needs to be fit for public consumption.

==“When an interaction designer has done a particularly good job, the user will be quite unaware of the designer’s presence… When the interaction designer has accomplished something particularly good, users won’t even notice it. In an industry that promotes ‘coolness’ as a design objective, it really gets tiresome to find my way so often obscured by interaction artifacts that have obviously taken some poor programmer lots of time and work… Many designers thing that good design is cool, and occasionally it is, but no matter how cool your interface is, less of it would be better.==” (p199). This is kind of a huge shift in thinking from novelty to stability. How do you balance innovation with comfort?

Cooper warns readers of the trap of ‘customer-driven design’, in which companies appease every complaint and suggestion of customers. This leads to short-term gains but long-term bloat and chaos, as there is no long-term plan for the product or company. He elaborates, ==“customer-driven products don’t have coherent design. They lack what software guru Frederick Brooks calls ‘conceptual integrity’, a single-minded vision of a program, which, he goes on to say, is the most important ingredient for success.==” (p219).

Cooper explains the necessity for quality interaction design, ==“when the users of software-based products were few, they were also the insiders, who knew how difficult software’s feats were. As the technology explodes into the mainstream, those who partake of its power are less aware of the greatness of the accomplishment. They are not willing to forgive a product with bad interaction just because building it was difficult.==” (p239). It’s kind of insane how little most people know about how computers work, considering how much of everyday life and work takes place with or through them. We may be tackling the wrong issue here, because do people really need easy-to-use programs, or do they need some basic understanding of computing and programming? Then they could use (or at least troubleshoot through) all the complex programs that programmers make. We learn to read and write in school, and those are foundational skills in all future endeavours. We learn about cells and electricity and other phenomena of the world. Should there not be education about how computers work too, considering how for better or for worse they are so entrenched in our lives? Why are we trying to keep people ignorant by abstracting the system image from the implementation model instead of just teaching them how to read the implementation? I guess it’s easier to market than to educate.

